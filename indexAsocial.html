
<!doctype html> 
  <head> 
  <meta charset>   
    <h1 style=" margin-left: 30%;">Reynolds 2D BOID model</h1> 
  </head> 

  <body>
    
   <div id="myDiv"><!-- Plotly chart will be drawn inside this DIV --></div>
  </body>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.js"></script>
  <!-- <script language="javascript"  src='/p5/p5.min.js'></script> -->

  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- <script src="asocialReynolds.js"></script> -->
  
  <script type="text/javascript">

var Engine = Matter.Engine;
var World = Matter.World;
var Bodies = Matter.Bodies;
var Body = Matter.Body

var engine;
var world;
var box1;


// Starting Variables
var nIndividuals = 50
var baseVelocity = 1
var spatialDistribution = 100
var centerStart = 400
var nSteps = 200
var bodySize = 8

var width = 1500
var height = 700



var flock; 






function setup() {
  Math.randomGaussian = function(mean, standardDeviation) {
 

     if (Math.randomGaussian.nextGaussian !== undefined) {
         var nextGaussian = Math.randomGaussian.nextGaussian;
         delete Math.randomGaussian.nextGaussian;
         return (nextGaussian * standardDeviation) + mean;
     } else {
         var v1, v2, s, multiplier;
         do {
             v1 = 2 * Math.random() - 1; // between -1 and 1
             v2 = 2 * Math.random() - 1; // between -1 and 1
             s = v1 * v1 + v2 * v2;
         } while (s >= 1 || s == 0);
         multiplier = Math.sqrt(-2 * Math.log(s) / s);
         Math.randomGaussian.nextGaussian = v2 * multiplier;
         return (v1 * multiplier * standardDeviation) + mean;
     }
 
};
  createCanvas(1500, 700)
  

  engine = Engine.create();
  engine.world.gravity.y = 0;
  world = engine.world;
      

  flock = new Flock()

  for(var o = 0; o <nIndividuals; o++) {
    

    var tempX = Math.randomGaussian(centerStart,spatialDistribution)
    var tempY = Math.randomGaussian(centerStart,spatialDistribution)
    // var tempAngle = Math.randomGaussian(180,40)

    var newBoid = new Boid(o, tempX, tempY, baseVelocity, baseVelocity);
    
    flock.addBoid(newBoid);

  }


  Engine.run(engine);
}

function draw() {
  background(51);
  flock.run();
}



function Flock() {
  this.boids = [];
}


Flock.prototype.run = function() {
  for(var i =0; i < this.boids.length; i++) {
    this.boids[i].run(this.boids)
  }
}


Flock.prototype.addBoid = function(b) {
  this.boids.push(b)
}

// Object that represents a boid.
function Boid(count, locx, locy, xvel, yvel) {
  this.acceleration = createVector(0,0);
  this.index = count;
  this.position = createVector(locx,locy)
  this.velocity = createVector(xvel,yvel)
  this.r = 3.0;
  this.maxspeed = 3;
  this.maxforce = 0.05;
  // console.log(this.velocity)
  this.body = Bodies.circle(xvel, yvel, bodySize, bodySize)
  World.add(world, this.body);
}



Boid.prototype.run = function(boids) {
  this.flock(boids)
  this.update();
  this.borders();
  this.render();
}

Boid.prototype.applyForce = function(force) {
  this.acceleration.add(force)
}

Boid.prototype.flock = function(boids) {
  var lightAttraction = this.attraction(createVector(1500/2, 700/2))
  var collision = this.separate(boids)

  // Weight of the attraction force
  lightAttraction.mult(.2)
  collision.mult(5)

  this.applyForce(lightAttraction)
  this.applyForce(collision)
}

Boid.prototype.update = function() {

  this.velocity.add(this.acceleration)
  // this.velocity.limit(this.maxspeed);
  this.position.add(this.velocity);
  this.acceleration = createVector(0,0)
}

Boid.prototype.attraction  = function(target) {
  var desired = p5.Vector.sub(target, this.position)
  // Normalize desired and scale to maximum speed
  desired.normalize();
  desired = desired.mult(this.maxspeed);
  // Steering = Desired minus Velocity
  var steer = p5.Vector.sub(desired, this.velocity);

  steer.limit(this.maxforce);  // Limit to maximum steering force
  return steer;
}

Boid.prototype.separate = function(boids) {
  var desiredseparation = 10;
  var steer = createVector(0,0);
  var count = 0;
  // For every boid in the system, check if it's too close
  for (var i = 0; i < boids.length; i++) {
    var d = p5.Vector.dist(this.position,boids[i].position);
    // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
    if ((d > 0) && (d < desiredseparation)) {
      // Calculate vector pointing away from neighbor
      var diff = p5.Vector.sub(this.position,boids[i].position);
      diff.normalize();
      diff.div(d);        // Weight by distance
      steer.add(diff);
      count++;            // Keep track of how many
    }
  }
  // Average -- divide by how many
  if (count > 0) {
    steer.div(count);
  }

  // As long as the vector is greater than 0
  if (steer.mag() > 0) {
    // Implement Reynolds: Steering = Desired - Velocity
    steer.normalize();
    steer.mult(this.maxspeed);
    steer.sub(this.velocity);
    steer.limit(this.maxforce);
  }
  return steer;
}

Boid.prototype.render = function() {
  // console.log(this.velocity)
  var theta = this.velocity.heading() + radians(90)
  fill(127)
  stroke(200)
  push()
  translate(this.position.x, this.position.y);
  rotate(theta);
  beginShape();
  vertex(0, -this.r*2);
  vertex(-this.r, this.r*2);
  vertex(this.r, this.r*2);
  endShape(CLOSE);
  pop();
}

Boid.prototype.borders = function() {
  if (this.position.x < -this.r)  this.position.x = width +this.r;
  if (this.position.y < -this.r)  this.position.y = height+this.r;
  if (this.position.x > width +this.r) this.position.x = -this.r;
  if (this.position.y > height+this.r) this.position.y = -this.r;
}

// Helpper function for printing the location of a swarm.
function printBoidLocation(boid) {
  console.log("Boid loc: " +[boid.xPosition, boid.yPosition])
}


function computeCartDist(x1,x2,y1,y2) {
  var a = x1 - x2 
  var b = y1 - y2 
  var c = Math.sqrt(a*a + b*b)
  return c
}

function calculateGroupDist(swarm) {
  var groupedDistance = 0
  for(i=0; i<nIndividuals; i++) {
    for(j=0;j<nIndividuals; j++) {
      var tempDist = computeCartDist(swarm[i].xPosition,swarm[j].xPosition,swarm[i].yPosition, swarm[j].yPosition);
      // console.log(tempDist)
      groupedDistance = groupedDistance + tempDist;
    } 
  }
  // console.log("Grouped distance: "+groupedDistance)
  return groupedDistance;
}

function calculateGSI(groupedDistancePrev,groupedDistanceNext) {
  // console.log("groupedDistancePrev: "+ groupedDistancePrev)
  // console.log("groupedDistanceNext: "+ groupedDistanceNext)
  var finalGSI = 1 - (((Math.abs(groupedDistancePrev - groupedDistanceNext)) / 4 ) / (nIndividuals*(nIndividuals-1)/2))
  // console.log(finalGSI)

  // console.log(finalGSI)
  return finalGSI
}

 


/////////////////
  </script>
</html>'