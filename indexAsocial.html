<!doctype html> 
	<head> 
	<meta charset>   
		<h1 style=" margin-left: 30%;">Reynolds 2D BOID model</h1> 
	</head> 

	<body>
		
	 <div id="myDiv"><!-- Plotly chart will be drawn inside this DIV --></div>
	</body>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.js"></script>
  <!-- <script language="javascript"  src='/p5/p5.min.js'></script> -->

	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<!-- <script src="asocialReynolds.js"></script> -->
	
	<script type="text/javascript">

var Engine = Matter.Engine;
var World = Matter.World;
var Bodies = Matter.Bodies;
var Body = Matter.Body

var engine;
var world;
var box1;


// Starting Variables
var nIndividuals = 50
var baseVelocity = 1
var spatialDistribution = 100
var centerStart = 400
var nSteps = 200
var bodySize = 8



// Load the gaussian package in order to sample from normal 
// distributions.
// var normalDist = require("gaussian")


Math.randomGaussian = function(mean, standardDeviation) {
 

     if (Math.randomGaussian.nextGaussian !== undefined) {
         var nextGaussian = Math.randomGaussian.nextGaussian;
         delete Math.randomGaussian.nextGaussian;
         return (nextGaussian * standardDeviation) + mean;
     } else {
         var v1, v2, s, multiplier;
         do {
             v1 = 2 * Math.random() - 1; // between -1 and 1
             v2 = 2 * Math.random() - 1; // between -1 and 1
             s = v1 * v1 + v2 * v2;
         } while (s >= 1 || s == 0);
         multiplier = Math.sqrt(-2 * Math.log(s) / s);
         Math.randomGaussian.nextGaussian = v2 * multiplier;
         return (v1 * multiplier * standardDeviation) + mean;
     }
 
 };


function findCenterOfMass(swarm) {
  var totalY = 0
  var totalX = 0
  for(t=0;t<nIndividuals;t++){
    totalX = totalX + swarm[t].body.position.x
    totalY = totalY + swarm[t].body.position.y
  }
  var averageX = totalX / nIndividuals
  var averageY = totalY / nIndividuals
  var centerMass = [averageX/2,averageY/2]

  // console.log("Center mass rule is: " + centerMass)

  return centerMass

}
// Object that represents a boid.
function Boid(count, locx, locy, xvel, yvel, ang) {
  this.index = count
  this.xPosition = locx
  this.yPosition = locy
  this.xvlc = xvel
  this.yvlc = yvel
  this.angle = ang
  this.body = Bodies.circle(locx, locy, bodySize, bodySize)
  World.add(world, this.body);
  this.show = function() {

    
    // Bodies.setAngularVelocity(this.body, )
    Body.setVelocity(this.body, {x:this.xvlc, y: this.yvlc})
      
      // var canvas = document.getElementById("defaultCanvas0")
      // console.log(canvas)
      // var ctx = canvas.getContext('2d')
      // push()
      // translate(newCor[0],newCor[1]);
      // pop()
     var pos = this.body.position
    var angle = this.body.angle;

    push()
    // translate(pos.x,pos.y)
    ellipse(pos.x,pos.y, bodySize, bodySize)
    pop();
  }
  // this.reframe = function(swarmA) {
  //   var canvas = document.getElementById("defaultCanvas0")
  //   var context = canvas.getContext('2d')
  //   console.log(context)
  //   var newCor = findCenterOfMass(swarmA)
  //   context.translate(newCor[0], newCor[1])


  // }
}

// Helpper function for printing the location of a swarm.
function printBoidLocation(boid) {
  console.log("Boid loc: " +[boid.xPosition, boid.yPosition])
}

// 
function initializeSwarm(swarm) {
  for(h = 0; h < nIndividuals; h ++) {

    // var distribution = normalDist(centerStart, spatialDistribution);

    // Generate x,y coordinates from the random distribution we generated.
    // var tempX = distribution.ppf(Math.random());
    // var tempY = distribution.ppf(Math.random());
    var tempX = Math.randomGaussian(centerStart,spatialDistribution)
    var tempY = Math.randomGaussian(centerStart,spatialDistribution)
    var tempAngle = Math.randomGaussian(180,40)

    var tempBoid = new Boid(h, tempX, tempY, baseVelocity, baseVelocity, tempAngle);
    
    swarm.push(tempBoid);

    // printBoidLocation(tempBoid)
  } 
  // console.log("Initialized Swarm:" + swarm)
  return swarm
}


function computeCartDist(x1,x2,y1,y2) {
  var a = x1 - x2 
  var b = y1 - y2 
  var c = Math.sqrt(a*a + b*b)
  return c
}

function calculateGroupDist(swarm) {
  var groupedDistance = 0
  for(i=0; i<nIndividuals; i++) {
    for(j=0;j<nIndividuals; j++) {
      var tempDist = computeCartDist(swarm[i].xPosition,swarm[j].xPosition,swarm[i].yPosition, swarm[j].yPosition);
      // console.log(tempDist)
      groupedDistance = groupedDistance + tempDist;
    } 
  }
  // console.log("Grouped distance: "+groupedDistance)
  return groupedDistance;
}

function calculateGSI(groupedDistancePrev,groupedDistanceNext) {
  // console.log("groupedDistancePrev: "+ groupedDistancePrev)
  // console.log("groupedDistanceNext: "+ groupedDistanceNext)
  var finalGSI = 1 - (((Math.abs(groupedDistancePrev - groupedDistanceNext)) / 4 ) / (nIndividuals*(nIndividuals-1)/2))
  // console.log(finalGSI)

  // console.log(finalGSI)
  return finalGSI
}



 
  var swarmArray = []
  
    function setup() { 
      createCanvas(1500,700)
      engine = Engine.create();
      engine.world.gravity.y = 0;
      world = engine.world;
      swarmArray = initializeSwarm(swarmArray)
      Engine.run(engine);
    }

    function draw() {
      background(51)

      // console.log(newCor)
    
  

      for(var v = 0; v < nIndividuals; v++) {
        // push()
        
        swarmArray[v].show()
        // swarmArray[v].reframe(swarmArray)
        // pop()
        
      }
      // push()
      
      // pop()
    }


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// async function demo() {
 
// 	for(o = 0; o < arenaLog.length; o ++) {
// 		 	currentArena = arenaLog[o]
// 		 	var xList = []
// 			var yList = []
// 		for(h = 0; h < swarmArray.length; h++) {
// 			xList.push(currentArena[h].xPosition)
// 			yList.push(currentArena[h].yPosition)
// 		}


// 		var trace1 = {
// 		  x: xList,
// 		  y: yList,
// 		  mode: 'markers',
// 		  type: 'scatter'
// 		};

// 		var data = [trace1];

// 		Plotly.newPlot('myDiv', data);
// 		await sleep(1000);

// 	}

// }


// demo();






/////////////////
	</script>
</html>'